/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app.js":
/*!****************!*\
  !*** ./app.js ***!
  \****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _kontra_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./kontra.js */ \"./kontra.js\");\n\nkontra.init(\"sky_elephant_window\");\nkontra.sprite();\n\n//# sourceURL=webpack:///./app.js?");

/***/ }),

/***/ "./kontra.js":
/*!*******************!*\
  !*** ./kontra.js ***!
  \*******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/*\r\n * Kontra.js v4.0.1 (Custom Build on 2018-08-19) | MIT\r\n * Build: https://straker.github.io/kontra/download?files=gameLoop+keyboard+sprite+assets+pool+pointer+quadtree+spriteSheet+tileEngine+store\r\n */\nkontra = {\n\n  /**\r\n   * Initialize the canvas.\r\n   * @memberof kontra\r\n   *\r\n   * @param {string|HTMLCanvasElement} canvas - Main canvas ID or Element for the game.\r\n   */\n  init(canvas) {\n\n    // check if canvas is a string first, an element next, or default to getting\n    // first canvas on page\n    var canvasEl = this.canvas = document.getElementById(canvas) || canvas || document.querySelector('canvas');\n\n    // @if DEBUG\n    if (!canvasEl) {\n      throw Error('You must provide a canvas element for the game');\n    }\n    // @endif\n\n    this.context = canvasEl.getContext('2d');\n  },\n\n  /**\r\n   * Noop function.\r\n   * @see https://stackoverflow.com/questions/21634886/what-is-the-javascript-convention-for-no-operation#comment61796464_33458430\r\n   * @memberof kontra\r\n   * @private\r\n   *\r\n   * The new operator is required when using sinon.stub to replace with the noop.\r\n   */\n  _noop: new Function(),\n\n  /**\r\n   * Dispatch event to any part of the code that needs to know when\r\n   * a new frame has started. Will be filled out in pointer events.\r\n   * @memberOf kontra\r\n   * @private\r\n   */\n  _tick: new Function()\n};\n\n(function () {\n\n  /**\r\n   * Game loop that updates and renders the game every frame.\r\n   * @memberof kontra\r\n   *\r\n   * @param {object}   properties - Properties of the game loop.\r\n   * @param {number}   [properties.fps=60] - Desired frame rate.\r\n   * @param {boolean}  [properties.clearCanvas=true] - Clear the canvas every frame.\r\n   * @param {function} properties.update - Function called to update the game.\r\n   * @param {function} properties.render - Function called to render the game.\r\n   */\n  kontra.gameLoop = function (properties) {\n    properties = properties || {};\n\n    // check for required functions\n    // @if DEBUG\n    if (!(properties.update && properties.render)) {\n      throw Error('You must provide update() and render() functions');\n    }\n    // @endif\n\n    // animation variables\n    let fps = properties.fps || 60;\n    let accumulator = 0;\n    let delta = 1E3 / fps; // delta between performance.now timings (in ms)\n    let step = 1 / fps;\n\n    let clear = properties.clearCanvas === false ? kontra._noop : function clear() {\n      kontra.context.clearRect(0, 0, kontra.canvas.width, kontra.canvas.height);\n    };\n    let last, rAF, now, dt;\n\n    /**\r\n     * Called every frame of the game loop.\r\n     */\n    function frame() {\n      rAF = requestAnimationFrame(frame);\n\n      now = performance.now();\n      dt = now - last;\n      last = now;\n\n      // prevent updating the game with a very large dt if the game were to lose focus\n      // and then regain focus later\n      if (dt > 1E3) {\n        return;\n      }\n\n      kontra._tick();\n      accumulator += dt;\n\n      while (accumulator >= delta) {\n        gameLoop.update(step);\n\n        accumulator -= delta;\n      }\n\n      clear();\n      gameLoop.render();\n    }\n\n    // game loop object\n    let gameLoop = {\n      update: properties.update,\n      render: properties.render,\n      isStopped: true,\n\n      /**\r\n       * Start the game loop.\r\n       * @memberof kontra.gameLoop\r\n       */\n      start() {\n        last = performance.now();\n        this.isStopped = false;\n        requestAnimationFrame(frame);\n      },\n\n      /**\r\n       * Stop the game loop.\r\n       */\n      stop() {\n        this.isStopped = true;\n        cancelAnimationFrame(rAF);\n      },\n\n      // expose properties for testing\n      // @if DEBUG\n      _frame: frame,\n      set _last(value) {\n        last = value;\n      }\n      // @endif\n    };\n\n    return gameLoop;\n  };\n})();\n\n(function () {\n  let callbacks = {};\n  let pressedKeys = {};\n\n  let keyMap = {\n    // named keys\n    13: 'enter',\n    27: 'esc',\n    32: 'space',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down'\n  };\n\n  // alpha keys\n  // @see https://stackoverflow.com/a/43095772/2124254\n  for (let i = 0; i < 26; i++) {\n    keyMap[65 + i] = (10 + i).toString(36);\n  }\n  // numeric keys\n  for (i = 0; i < 10; i++) {\n    keyMap[48 + i] = '' + i;\n  }\n\n  addEventListener('keydown', keydownEventHandler);\n  addEventListener('keyup', keyupEventHandler);\n  addEventListener('blur', blurEventHandler);\n\n  /**\r\n   * Execute a function that corresponds to a keyboard key.\r\n   * @private\r\n   *\r\n   * @param {Event} e\r\n   */\n  function keydownEventHandler(e) {\n    let key = keyMap[e.which];\n    pressedKeys[key] = true;\n\n    if (callbacks[key]) {\n      callbacks[key](e);\n    }\n  }\n\n  /**\r\n   * Set the released key to not being pressed.\r\n   * @private\r\n   *\r\n   * @param {Event} e\r\n   */\n  function keyupEventHandler(e) {\n    pressedKeys[keyMap[e.which]] = false;\n  }\n\n  /**\r\n   * Reset pressed keys.\r\n   * @private\r\n   *\r\n   * @param {Event} e\r\n   */\n  function blurEventHandler(e) {\n    pressedKeys = {};\n  }\n\n  /**\r\n   * Object for using the keyboard.\r\n   */\n  kontra.keys = {\n    /**\r\n     * Register a function to be called on a key press.\r\n     * @memberof kontra.keys\r\n     *\r\n     * @param {string|string[]} keys - key or keys to bind.\r\n     */\n    bind(keys, callback) {\n      // smaller than doing `Array.isArray(keys) ? keys : [keys]`\n      [].concat(keys).map(function (key) {\n        callbacks[key] = callback;\n      });\n    },\n\n    /**\r\n     * Remove the callback function for a key.\r\n     * @memberof kontra.keys\r\n     *\r\n     * @param {string|string[]} keys - key or keys to unbind.\r\n     */\n    unbind(keys, undefined) {\n      [].concat(keys).map(function (key) {\n        callbacks[key] = undefined;\n      });\n    },\n\n    /**\r\n     * Returns whether a key is pressed.\r\n     * @memberof kontra.keys\r\n     *\r\n     * @param {string} key - Key to check for press.\r\n     *\r\n     * @returns {boolean}\r\n     */\n    pressed(key) {\n      return !!pressedKeys[key];\n    }\n  };\n})();\n\n(function () {\n\n  class Vector {\n    /**\r\n     * Initialize the vectors x and y position.\r\n     * @memberof kontra.vector\r\n     * @private\r\n     *\r\n     * @param {number} [x=0] - X coordinate.\r\n     * @param {number} [y=0] - Y coordinate.\r\n     *\r\n     * @returns {vector}\r\n     */\n    constructor(x, y) {\n      this._x = x || 0;\n      this._y = y || 0;\n    }\n\n    /**\r\n     * Add a vector to this vector.\r\n     * @memberof kontra.vector\r\n     *\r\n     * @param {vector} vector - Vector to add.\r\n     * @param {number} dt=1 - Time since last update.\r\n     */\n    add(vector, dt) {\n      this.x += (vector.x || 0) * (dt || 1);\n      this.y += (vector.y || 0) * (dt || 1);\n    }\n\n    /**\r\n     * Clamp the vector between two points that form a rectangle.\r\n     * @memberof kontra.vector\r\n     *\r\n     * @param {number} xMin - Min x value.\r\n     * @param {number} yMin - Min y value.\r\n     * @param {number} xMax - Max x value.\r\n     * @param {number} yMax - Max y value.\r\n     */\n    clamp(xMin, yMin, xMax, yMax) {\n      this._c = true;\n      this._a = xMin;\n      this._b = yMin;\n      this._d = xMax;\n      this._e = yMax;\n    }\n\n    /**\r\n     * Vector x\r\n     * @memberof kontra.vector\r\n     *\r\n     * @property {number} x\r\n     */\n    get x() {\n      return this._x;\n    }\n\n    /**\r\n     * Vector y\r\n     * @memberof kontra.vector\r\n     *\r\n     * @property {number} y\r\n     */\n    get y() {\n      return this._y;\n    }\n\n    set x(value) {\n      this._x = this._c ? Math.min(Math.max(this._a, value), this._d) : value;\n    }\n\n    set y(value) {\n      this._y = this._c ? Math.min(Math.max(this._b, value), this._e) : value;\n    }\n  }\n\n  /**\r\n   * A vector for 2D space.\r\n   * @memberof kontra\r\n   *\r\n   * @param {number} [x=0] - X coordinate.\r\n   * @param {number} [y=0] - Y coordinate.\r\n   */\n  kontra.vector = (x, y) => {\n    return new Vector(x, y);\n  };\n  kontra.vector.prototype = Vector.prototype;\n\n  class Sprite {\n    /**\r\n     * Initialize properties on the sprite.\r\n     * @memberof kontra.sprite\r\n     *\r\n     * @param {object} properties - Properties of the sprite.\r\n     * @param {number} properties.x - X coordinate of the sprite.\r\n     * @param {number} properties.y - Y coordinate of the sprite.\r\n     * @param {number} [properties.dx] - Change in X position.\r\n     * @param {number} [properties.dy] - Change in Y position.\r\n     * @param {number} [properties.ddx] - Change in X velocity.\r\n     * @param {number} [properties.ddy] - Change in Y velocity.\r\n     *\r\n     * @param {number} [properties.ttl=0] - How may frames the sprite should be alive.\r\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\r\n     *\r\n     * @param {Image|Canvas} [properties.image] - Image for the sprite.\r\n     *\r\n     * @param {object} [properties.animations] - Animations for the sprite instead of an image.\r\n     *\r\n     * @param {string} [properties.color] - If no image or animation is provided, use color to draw a rectangle for the sprite.\r\n     * @param {number} [properties.width] - Width of the sprite for drawing a rectangle.\r\n     * @param {number} [properties.height] - Height of the sprite for drawing a rectangle.\r\n     *\r\n     * @param {function} [properties.update] - Function to use to update the sprite.\r\n     * @param {function} [properties.render] - Function to use to render the sprite.\r\n     *\r\n     * If you need the sprite to live forever, or just need it to stay on screen until you\r\n     * decide when to kill it, you can set <code>ttl</code> to <code>Infinity</code>.\r\n     * Just be sure to set <code>ttl</code> to 0 when you want the sprite to die.\r\n     */\n    // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n    init(properties, prop, temp, firstAnimation) {\n      properties = properties || {};\n\n      this.position = kontra.vector(properties.x, properties.y);\n      this.velocity = kontra.vector(properties.dx, properties.dy);\n      this.acceleration = kontra.vector(properties.ddx, properties.ddy);\n\n      // defaults\n      this.width = this.height = 0;\n      this.context = kontra.context;\n\n      // loop through properties before overrides\n      for (prop in properties) {\n        this[prop] = properties[prop];\n      }\n\n      // image sprite\n      if (temp = properties.image) {\n        this.image = temp;\n        this.width = temp.width;\n        this.height = temp.height;\n      }\n      // animation sprite\n      else if (temp = properties.animations) {\n\n          // clone each animation so no sprite shares an animation\n          for (prop in temp) {\n            this.animations[prop] = temp[prop].clone();\n\n            // default the current animation to the first one in the list\n            firstAnimation = firstAnimation || temp[prop];\n          }\n\n          this._ca = firstAnimation;\n          this.width = firstAnimation.width;\n          this.height = firstAnimation.height;\n        }\n\n      return this;\n    }\n\n    // define getter and setter shortcut functions to make it easier to work with the\n    // position, velocity, and acceleration vectors.\n\n    /**\r\n     * Sprite position.x\r\n     * @memberof kontra.sprite\r\n     *\r\n     * @property {number} x\r\n     */\n    get x() {\n      return this.position.x;\n    }\n\n    /**\r\n     * Sprite position.y\r\n     * @memberof kontra.sprite\r\n     *\r\n     * @property {number} y\r\n     */\n    get y() {\n      return this.position.y;\n    }\n\n    /**\r\n     * Sprite velocity.x\r\n     * @memberof kontra.sprite\r\n     *\r\n     * @property {number} dx\r\n     */\n    get dx() {\n      return this.velocity.x;\n    }\n\n    /**\r\n     * Sprite velocity.y\r\n     * @memberof kontra.sprite\r\n     *\r\n     * @property {number} dy\r\n     */\n    get dy() {\n      return this.velocity.y;\n    }\n\n    /**\r\n     * Sprite acceleration.x\r\n     * @memberof kontra.sprite\r\n     *\r\n     * @property {number} ddx\r\n     */\n    get ddx() {\n      return this.acceleration.x;\n    }\n\n    /**\r\n     * Sprite acceleration.y\r\n     * @memberof kontra.sprite\r\n     *\r\n     * @property {number} ddy\r\n     */\n    get ddy() {\n      return this.acceleration.y;\n    }\n\n    set x(value) {\n      this.position.x = value;\n    }\n    set y(value) {\n      this.position.y = value;\n    }\n    set dx(value) {\n      this.velocity.x = value;\n    }\n    set dy(value) {\n      this.velocity.y = value;\n    }\n    set ddx(value) {\n      this.acceleration.x = value;\n    }\n    set ddy(value) {\n      this.acceleration.y = value;\n    }\n\n    /**\r\n     * Determine if the sprite is alive.\r\n     * @memberof kontra.sprite\r\n     *\r\n     * @returns {boolean}\r\n     */\n    isAlive() {\n      return this.ttl > 0;\n    }\n\n    /**\r\n     * Simple bounding box collision test.\r\n     * @memberof kontra.sprite\r\n     *\r\n     * @param {object} object - Object to check collision against.\r\n     *\r\n     * @returns {boolean} True if the objects collide, false otherwise.\r\n     */\n    collidesWith(object) {\n      return this.x < object.x + object.width && this.x + this.width > object.x && this.y < object.y + object.height && this.y + this.height > object.y;\n    }\n\n    /**\r\n     * Update the sprites velocity and position.\r\n     * @memberof kontra.sprite\r\n     * @abstract\r\n     *\r\n     * @param {number} dt - Time since last update.\r\n     *\r\n     * This function can be overridden on a per sprite basis if more functionality\r\n     * is needed in the update step. Just call <code>this.advance()</code> when you need\r\n     * the sprite to update its position.\r\n     *\r\n     * @example\r\n     * sprite = kontra.sprite({\r\n     *   update: function update(dt) {\r\n     *     // do some logic\r\n     *\r\n     *     this.advance(dt);\r\n     *   }\r\n     * });\r\n     */\n    update(dt) {\n      this.advance(dt);\n    }\n\n    /**\r\n     * Render the sprite.\r\n     * @memberof kontra.sprite.\r\n     * @abstract\r\n     *\r\n     * This function can be overridden on a per sprite basis if more functionality\r\n     * is needed in the render step. Just call <code>this.draw()</code> when you need the\r\n     * sprite to draw its image.\r\n     *\r\n     * @example\r\n     * sprite = kontra.sprite({\r\n     *   render: function render() {\r\n     *     // do some logic\r\n     *\r\n     *     this.draw();\r\n     *   }\r\n     * });\r\n     */\n    render() {\n      this.draw();\n    }\n\n    /**\r\n     * Play an animation.\r\n     * @memberof kontra.sprite\r\n     *\r\n     * @param {string} name - Name of the animation to play.\r\n     */\n    playAnimation(name) {\n      this._ca = this.animations[name];\n\n      if (!this._ca.loop) {\n        this._ca.reset();\n      }\n    }\n\n    /**\r\n     * Advance the sprites position, velocity, and current animation (if it\r\n     * has one).\r\n     * @memberof kontra.sprite\r\n     *\r\n     * @param {number} dt - Time since last update.\r\n     */\n    advance(dt) {\n      this.velocity.add(this.acceleration, dt);\n      this.position.add(this.velocity, dt);\n\n      this.ttl--;\n\n      if (this._ca) {\n        this._ca.update(dt);\n      }\n    }\n\n    /**\r\n     * Draw the sprite to the canvas.\r\n     * @memberof kontra.sprite\r\n     */\n    draw() {\n      if (this.image) {\n        this.context.drawImage(this.image, this.x, this.y);\n      } else if (this._ca) {\n        this._ca.render(this);\n      } else {\n        this.context.fillStyle = this.color;\n        this.context.fillRect(this.x, this.y, this.width, this.height);\n      }\n    }\n  };\n\n  /**\r\n   * A sprite with a position, velocity, and acceleration.\r\n   * @memberof kontra\r\n   * @requires kontra.vector\r\n   *\r\n   * @param {object} properties - Properties of the sprite.\r\n   * @param {number} properties.x - X coordinate of the sprite.\r\n   * @param {number} properties.y - Y coordinate of the sprite.\r\n   * @param {number} [properties.dx] - Change in X position.\r\n   * @param {number} [properties.dy] - Change in Y position.\r\n   * @param {number} [properties.ddx] - Change in X velocity.\r\n   * @param {number} [properties.ddy] - Change in Y velocity.\r\n   *\r\n   * @param {number} [properties.ttl=0] - How may frames the sprite should be alive.\r\n   * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\r\n   *\r\n   * @param {Image|Canvas} [properties.image] - Image for the sprite.\r\n   *\r\n   * @param {object} [properties.animations] - Animations for the sprite instead of an image.\r\n   *\r\n   * @param {string} [properties.color] - If no image or animation is provided, use color to draw a rectangle for the sprite.\r\n   * @param {number} [properties.width] - Width of the sprite for drawing a rectangle.\r\n   * @param {number} [properties.height] - Height of the sprite for drawing a rectangle.\r\n   *\r\n   * @param {function} [properties.update] - Function to use to update the sprite.\r\n   * @param {function} [properties.render] - Function to use to render the sprite.\r\n   */\n  kontra.sprite = properties => {\n    return new Sprite().init(properties);\n  };\n  kontra.sprite.prototype = Sprite.prototype;\n})();\n\n(function () {\n  let imageRegex = /(jpeg|jpg|gif|png)$/;\n  let audioRegex = /(wav|mp3|ogg|aac)$/;\n  let noRegex = /^no$/;\n  let leadingSlash = /^\\//;\n  let trailingSlash = /\\/$/;\n  let assets;\n\n  // audio playability\n  // @see https://github.com/Modernizr/Modernizr/blob/master/feature-detects/audio.js\n  let audio = new Audio();\n  let canUse = {\n    wav: '',\n    mp3: audio.canPlayType('audio/mpeg;').replace(noRegex, ''),\n    ogg: audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(noRegex, ''),\n    aac: audio.canPlayType('audio/aac;').replace(noRegex, '')\n  };\n\n  /**\r\n   * Join a base path and asset path.\r\n   *\r\n   * @param {string} base - The asset base path.\r\n   * @param {string} url - The URL to the asset.\r\n   *\r\n   * @returns {string}\r\n   */\n  function joinPath(base, url) {\n    return [base.replace(trailingSlash, ''), base ? url.replace(leadingSlash, '') : url].filter(s => s).join('/');\n  }\n\n  /**\r\n   * Get the extension of an asset.\r\n   *\r\n   * @param {string} url - The URL to the asset.\r\n   *\r\n   * @returns {string}\r\n   */\n  function getExtension(url) {\n    return url.split('.').pop();\n  }\n\n  /**\r\n   * Get the name of an asset.\r\n   *\r\n   * @param {string} url - The URL to the asset.\r\n   *\r\n   * @returns {string}\r\n   */\n  function getName(url) {\n    let name = url.replace('.' + getExtension(url), '');\n\n    // remove leading slash if there is no folder in the path\n    // @see https://stackoverflow.com/a/50592629/2124254\n    return name.split('/').length == 2 ? name.replace(leadingSlash, '') : name;\n  }\n\n  /**\r\n   * Load an Image file. Uses imagePath to resolve URL.\r\n   * @memberOf kontra.assets\r\n   * @private\r\n   *\r\n   * @param {string} url - The URL to the Image file.\r\n   *\r\n   * @returns {Promise} A deferred promise. Promise resolves with the Image.\r\n   *\r\n   * @example\r\n   * kontra.loadImage('car.png');\r\n   * kontra.loadImage('autobots/truck.png');\r\n   */\n  function loadImage(originalUrl, url) {\n    return new Promise(function (resolve, reject) {\n      let image = new Image();\n      url = joinPath(assets.imagePath, originalUrl);\n\n      image.onload = function loadImageOnLoad() {\n        assets.images[getName(originalUrl)] = assets.images[url] = this;\n        resolve(this);\n      };\n\n      image.onerror = function loadImageOnError() {\n        reject( /* @if DEBUG */'Unable to load image ' + /* @endif */url);\n      };\n\n      image.src = url;\n    });\n  }\n\n  /**\r\n   * Load an Audio file. Supports loading multiple audio formats which will be resolved by\r\n   * the browser in the order listed. Uses audioPath to resolve URL.\r\n   * @memberOf kontra.assets\r\n   * @private\r\n   *\r\n   * @param {string|string[]} url - The URL to the Audio file.\r\n   *\r\n   * @returns {Promise} A deferred promise. Promise resolves with the Audio.\r\n   *\r\n   * @example\r\n   * kontra.loadAudio('sound_effects/laser.mp3');\r\n   * kontra.loadAudio(['explosion.mp3', 'explosion.m4a', 'explosion.ogg']);\r\n   */\n  function loadAudio(originalUrl, url, undefined) {\n    return new Promise(function (resolve, reject) {\n\n      // determine which audio format the browser can play\n      originalUrl = [].concat(originalUrl).reduce(function (a, source) {\n        return canUse[getExtension(source)] ? source : a;\n      }, undefined);\n\n      if (!originalUrl) {\n        reject( /* @if DEBUG */'cannot play any of the audio formats provided' + /* @endif */originalUrl);\n      } else {\n        let audio = new Audio();\n        url = joinPath(assets.audioPath, originalUrl);\n\n        audio.addEventListener('canplay', function loadAudioOnLoad() {\n          assets.audio[getName(originalUrl)] = assets.audio[url] = this;\n          resolve(this);\n        });\n\n        audio.onerror = function loadAudioOnError() {\n          reject( /* @if DEBUG */'Unable to load audio ' + /* @endif */url);\n        };\n\n        audio.src = url;\n        audio.load();\n      }\n    });\n  }\n\n  /**\r\n   * Load a data file (be it text or JSON). Uses dataPath to resolve URL.\r\n   * @memberOf kontra.assets\r\n   * @private\r\n   *\r\n   * @param {string} url - The URL to the data file.\r\n   *\r\n   * @returns {Promise} A deferred promise. Resolves with the data or parsed JSON.\r\n   *\r\n   * @example\r\n   * kontra.loadData('bio.json');\r\n   * kontra.loadData('dialog.txt');\r\n   */\n  function loadData(originalUrl, url) {\n    url = joinPath(assets.dataPath, originalUrl);\n\n    return fetch(url).then(function (response) {\n      if (!response.ok) throw response;\n      return response.clone().json().catch(function () {\n        return response.text();\n      });\n    }).then(function (data) {\n      assets.data[getName(originalUrl)] = assets.data[url] = data;\n      return data;\n    });\n  }\n\n  /**\r\n   * Object for loading assets.\r\n   */\n  assets = kontra.assets = {\n    // all assets are stored by name as well as by URL\n    images: {},\n    audio: {},\n    data: {},\n\n    // base asset path for determining asset URLs\n    imagePath: '',\n    audioPath: '',\n    dataPath: '',\n\n    /**\r\n     * Load an Image, Audio, or data file.\r\n     * @memberOf kontra.assets\r\n     *\r\n     * @param {string|string[]} - Comma separated list of assets to load.\r\n     *\r\n     * @returns {Promise}\r\n     *\r\n     * @example\r\n     * kontra.loadAsset('car.png');\r\n     * kontra.loadAsset(['explosion.mp3', 'explosion.ogg']);\r\n     * kontra.loadAsset('bio.json');\r\n     * kontra.loadAsset('car.png', ['explosion.mp3', 'explosion.ogg'], 'bio.json');\r\n     */\n    load() {\n      let promises = [];\n      let url, extension, asset, i, promise;\n\n      for (i = 0; asset = arguments[i]; i++) {\n        url = [].concat(asset)[0];\n\n        extension = getExtension(url);\n        if (extension.match(imageRegex)) {\n          promise = loadImage(asset);\n        } else if (extension.match(audioRegex)) {\n          promise = loadAudio(asset);\n        } else {\n          promise = loadData(asset);\n        }\n\n        promises.push(promise);\n      }\n\n      return Promise.all(promises);\n    },\n\n    // expose properties for testing\n    /* @if DEBUG */\n    _canUse: canUse\n    /* @endif */\n  };\n})();\n\n(function () {\n\n  /**\r\n   * Object pool. The pool will grow in size to accommodate as many objects as are needed.\r\n   * Unused items are at the front of the pool and in use items are at the of the pool.\r\n   * @memberof kontra\r\n   *\r\n   * @param {object} properties - Properties of the pool.\r\n   * @param {function} properties.create - Function that returns the object to use in the pool.\r\n   * @param {number} properties.maxSize - The maximum size that the pool will grow to.\r\n   */\n  kontra.pool = function (properties) {\n    properties = properties || {};\n\n    let inUse = 0;\n\n    // check for the correct structure of the objects added to pools so we know that the\n    // rest of the pool code will work without errors\n    // @if DEBUG\n    let obj;\n    if (!properties.create || !(obj = properties.create()) || !(obj.update && obj.init && obj.isAlive)) {\n      throw Error('Must provide create() function which returns an object with init(), update(), and isAlive() functions');\n    }\n    // @endif\n\n    return {\n      _c: properties.create,\n\n      // start the pool with an object\n      objects: [properties.create()],\n      size: 1,\n      maxSize: properties.maxSize || Infinity,\n\n      /**\r\n       * Get an object from the pool.\r\n       * @memberof kontra.pool\r\n       *\r\n       * @param {object} properties - Properties to pass to object.init().\r\n       */\n      get(properties) {\n        properties = properties || {};\n\n        // the pool is out of objects if the first object is in use and it can't grow\n        if (this.objects[0].isAlive()) {\n          if (this.size === this.maxSize) {\n            return;\n          }\n          // double the size of the array by filling it with twice as many objects\n          else {\n              for (let x = 0; x < this.size && this.objects.length < this.maxSize; x++) {\n                this.objects.unshift(this._c());\n              }\n\n              this.size = this.objects.length;\n            }\n        }\n\n        // save off first object in pool to reassign to last object after unshift\n        let obj = this.objects.shift();\n        obj.init(properties);\n        this.objects.push(obj);\n        inUse++;\n      },\n\n      /**\r\n       * Return all objects that are alive from the pool.\r\n       * @memberof kontra.pool\r\n       *\r\n       * @returns {object[]}\r\n       */\n      getAliveObjects() {\n        return this.objects.slice(this.objects.length - inUse);\n      },\n\n      /**\r\n       * Clear the object pool.\r\n       * @memberof kontra.pool\r\n       */\n      clear() {\n        inUse = this.objects.length = 0;\n        this.size = 1;\n        this.objects.push(this._c());\n      },\n\n      /**\r\n       * Update all alive pool objects.\r\n       * @memberof kontra.pool\r\n       *\r\n       * @param {number} dt - Time since last update.\r\n       */\n      update(dt) {\n        let i = this.size - 1;\n        let obj;\n\n        // If the user kills an object outside of the update cycle, the pool won't know of\n        // the change until the next update and inUse won't be decremented. If the user then\n        // gets an object when inUse is the same size as objects.length, inUse will increment\n        // and this statement will evaluate to -1.\n        //\n        // I don't like having to go through the pool to kill an object as it forces you to\n        // know which object came from which pool. Instead, we'll just prevent the index from\n        // going below 0 and accept the fact that inUse may be out of sync for a frame.\n        let index = Math.max(this.objects.length - inUse, 0);\n\n        // only iterate over the objects that are alive\n        while (i >= index) {\n          obj = this.objects[i];\n\n          obj.update(dt);\n\n          // if the object is dead, move it to the front of the pool\n          if (!obj.isAlive()) {\n            this.objects = this.objects.splice(i, 1).concat(this.objects);\n            inUse--;\n            index++;\n          } else {\n            i--;\n          }\n        }\n      },\n\n      /**\r\n       * render all alive pool objects.\r\n       * @memberof kontra.pool\r\n       */\n      render() {\n        let index = Math.max(this.objects.length - inUse, 0);\n\n        for (let i = this.size - 1; i >= index; i--) {\n          this.objects[i].render();\n        }\n      }\n    };\n  };\n})();\n\n(function () {\n  let pointer;\n\n  // save each object as they are rendered to determine which object\n  // is on top when multiple objects are the target of an event.\n  // we'll always use the last frame's object order so we know\n  // the finalized order of all objects, otherwise an object could ask\n  // if it's being hovered when it's rendered first even if other objects\n  // would block it later in the render order\n  let thisFrameRenderOrder = [];\n  let lastFrameRenderOrder = [];\n\n  let callbacks = {};\n  let trackedObjects = [];\n  let pressedButtons = {};\n\n  let buttonMap = {\n    0: 'left',\n    1: 'middle',\n    2: 'right'\n  };\n\n  addEventListener('mousedown', pointerDownHandler);\n  addEventListener('touchstart', pointerDownHandler);\n  addEventListener('mouseup', pointerUpHandler);\n  addEventListener('touchend', pointerUpHandler);\n  addEventListener('blur', blurEventHandler);\n  addEventListener('mousemove', mouseMoveHandler);\n\n  /**\r\n   * Detection collision between a rectangle and a circle.\r\n   * @see https://yal.cc/rectangle-circle-intersection-test/\r\n   * @private\r\n   *\r\n   * @param {object} object - Object to check collision against.\r\n   */\n  function circleRectCollision(object) {\n    let dx = pointer.x - Math.max(object.x, Math.min(pointer.x, object.x + object.width));\n    let dy = pointer.y - Math.max(object.y, Math.min(pointer.y, object.y + object.height));\n    return dx * dx + dy * dy < pointer.radius * pointer.radius;\n  }\n\n  /**\r\n   * Get the first on top object that the pointer collides with.\r\n   * @private\r\n   *\r\n   * @returns {object} First object to collide with the pointer.\r\n   */\n  function getCurrentObject() {\n\n    // if pointer events are required on the very first frame or without a game loop,\n    // use the current frame order array\n    let frameOrder = lastFrameRenderOrder.length ? lastFrameRenderOrder : thisFrameRenderOrder;\n    let length = frameOrder.length - 1;\n    let object, collides;\n\n    for (let i = length; i >= 0; i--) {\n      object = frameOrder[i];\n\n      if (object.collidesWithPointer) {\n        collides = object.collidesWithPointer(pointer);\n      } else {\n        collides = circleRectCollision(object);\n      }\n\n      if (collides) {\n        return object;\n      }\n    }\n  }\n\n  /**\r\n   * Execute the onDown callback for an object.\r\n   * @private\r\n   *\r\n   * @param {Event} e\r\n   */\n  function pointerDownHandler(e) {\n    pressedButtons[buttonMap[e.button]] = true;\n    pointerHandler(e, 'onDown');\n  }\n\n  /**\r\n   * Execute the onUp callback for an object.\r\n   * @private\r\n   *\r\n   * @param {Event} e\r\n   */\n  function pointerUpHandler(e) {\n    pressedButtons[buttonMap[e.button]] = false;\n    pointerHandler(e, 'onUp');\n  }\n\n  /**\r\n   * Track the position of the mouse.\r\n   * @private\r\n   *\r\n   * @param {Event} e\r\n   */\n  function mouseMoveHandler(e) {\n    pointerHandler(e, 'onOver');\n  }\n\n  /**\r\n   * Reset pressed buttons.\r\n   * @private\r\n   *\r\n   * @param {Event} e\r\n   */\n  function blurEventHandler(e) {\n    pressedButtons = {};\n  }\n\n  /**\r\n   * Find the first object for the event and execute it's callback function\r\n   * @private\r\n   *\r\n   * @param {Event} e\r\n   * @param {string} event - Which event was called.\r\n   */\n  function pointerHandler(e, event) {\n    if (!kontra.canvas) return;\n\n    let clientX, clientY;\n\n    if (e.type.indexOf('mouse') !== -1) {\n      clientX = e.clientX;\n      clientY = e.clientY;\n    } else {\n      // touchstart uses touches while touchend uses changedTouches\n      // @see https://stackoverflow.com/questions/17957593/how-to-capture-touchend-coordinates\n      clientX = (e.touches[0] || e.changedTouches[0]).clientX;\n      clientY = (e.touches[0] || e.changedTouches[0]).clientY;\n    }\n\n    pointer.x = clientX - kontra.canvas.offsetLeft;\n    pointer.y = clientY - kontra.canvas.offsetTop;\n\n    let object;\n    if (e.target === kontra.canvas) {\n      object = getCurrentObject();\n      if (object && object[event]) {\n        object[event]();\n      }\n    }\n\n    if (callbacks[event]) {\n      callbacks[event](e, object);\n    }\n  }\n\n  /**\r\n   * Object for using the pointer.\r\n   */\n  pointer = kontra.pointer = {\n    x: 0,\n    y: 0,\n    radius: 5, // arbitrary size\n\n    /**\r\n     * Register object to be tracked by pointer events.\r\n     * @memberof kontra.pointer\r\n     *\r\n     * @param {object|object[]} objects - Object or objects to track.\r\n     */\n    track(objects) {\n      [].concat(objects).map(function (object) {\n\n        // override the objects render function to keep track of render order\n        if (!object._r) {\n          object._r = object.render;\n\n          object.render = function () {\n            thisFrameRenderOrder.push(this);\n            this._r();\n          };\n\n          trackedObjects.push(object);\n        }\n      });\n    },\n\n    /**\r\n     * Remove object from being tracked by pointer events.\r\n     * @memberof kontra.pointer\r\n     *\r\n     * @param {object|object[]} objects - Object or objects to stop tracking.\r\n     */\n    untrack(objects, undefined) {\n      [].concat(objects).map(function (object) {\n\n        // restore original render function to no longer track render order\n        object.render = object._r;\n        object._r = undefined;\n\n        let index = trackedObjects.indexOf(object);\n        if (index !== -1) {\n          trackedObjects.splice(index, 1);\n        }\n      });\n    },\n\n    /**\r\n     * Returns whether a tracked object is under the pointer.\r\n     * @memberof kontra.pointer\r\n     *\r\n     * @param {object} object - Object to check\r\n     *\r\n     * @returns {boolean}\r\n     */\n    over(object) {\n      if (trackedObjects.indexOf(object) === -1) return false;\n\n      return getCurrentObject() === object;\n    },\n\n    /**\r\n     * Register a function to be called on pointer down.\r\n     * @memberof kontra.pointer\r\n     *\r\n     * @param {function} callback - Function to execute\r\n     */\n    onDown(callback) {\n      callbacks.onDown = callback;\n    },\n\n    /**\r\n     * Register a function to be called on pointer up.\r\n     * @memberof kontra.pointer\r\n     *\r\n     * @param {function} callback - Function to execute\r\n     */\n    onUp(callback) {\n      callbacks.onUp = callback;\n    },\n\n    /**\r\n     * Returns whether the button is pressed.\r\n     * @memberof kontra.pointer\r\n     *\r\n     * @param {string} button - Button to check for press.\r\n     *\r\n     * @returns {boolean}\r\n     */\n    pressed(button) {\n      return !!pressedButtons[button];\n    }\n  };\n\n  // reset object render order on every new frame\n  kontra._tick = function () {\n    lastFrameRenderOrder.length = 0;\n\n    thisFrameRenderOrder.map(function (object) {\n      lastFrameRenderOrder.push(object);\n    });\n\n    thisFrameRenderOrder.length = 0;\n  };\n})();\n\n(function () {\n\n  /**\r\n   * A quadtree for 2D collision checking. The quadtree acts like an object pool in that it\r\n   * will create subnodes as objects are needed but it won't clean up the subnodes when it\r\n   * collapses to avoid garbage collection.\r\n   * @memberof kontra\r\n   *\r\n   * @param {object} properties - Properties of the quadtree.\r\n   * @param {number} [properties.maxDepth=3] - Maximum node depths the quadtree can have.\r\n   * @param {number} [properties.maxObjects=25] - Maximum number of objects a node can support before splitting.\r\n   * @param {object} [properties.bounds] - The 2D space this node occupies.\r\n   * @param {object} [properties.parent] - Private. The node that contains this node.\r\n   * @param {number} [properties.depth=0] - Private. Current node depth.\r\n   *\r\n   * The quadrant indices are numbered as follows (following a z-order curve):\r\n   *     |\r\n   *  0  |  1\r\n   * ----+----\r\n   *  2  |  3\r\n   *     |\r\n   */\n  kontra.quadtree = function (properties) {\n    properties = properties || {};\n\n    return {\n      maxDepth: properties.maxDepth || 3,\n      maxObjects: properties.maxObjects || 25,\n\n      // since we won't clean up any subnodes, we need to keep track of which nodes are\n      // currently the leaf node so we know which nodes to add objects to\n      // b = branch, d = depth, p = parent\n      _b: false,\n      _d: properties.depth || 0,\n      /* @if VISUAL_DEBUG */\n      _p: properties.parent,\n      /* @endif */\n\n      bounds: properties.bounds || {\n        x: 0,\n        y: 0,\n        width: kontra.canvas.width,\n        height: kontra.canvas.height\n      },\n\n      objects: [],\n      subnodes: [],\n\n      /**\r\n       * Clear the quadtree\r\n       * @memberof kontra.quadtree\r\n       */\n      clear() {\n        this.subnodes.map(function (subnode) {\n          subnode.clear();\n        });\n\n        this._b = false;\n        this.objects.length = 0;\n      },\n\n      /**\r\n       * Find the leaf node the object belongs to and get all objects that are part of\r\n       * that node.\r\n       * @memberof kontra.quadtree\r\n       *\r\n       * @param {object} object - Object to use for finding the leaf node.\r\n       *\r\n       * @returns {object[]} A list of objects in the same leaf node as the object.\r\n       */\n      get(object) {\n        let objects = [];\n        let indices, i;\n\n        // traverse the tree until we get to a leaf node\n        while (this.subnodes.length && this._b) {\n          indices = this._g(object);\n\n          for (i = 0; i < indices.length; i++) {\n            objects.push.apply(objects, this.subnodes[indices[i]].get(object));\n          }\n\n          return objects;\n        }\n\n        return this.objects;\n      },\n\n      /**\r\n       * Add an object to the quadtree. Once the number of objects in the node exceeds\r\n       * the maximum number of objects allowed, it will split and move all objects to their\r\n       * corresponding subnodes.\r\n       * @memberof kontra.quadtree\r\n       *\r\n       * @param {...object|object[]} Objects to add to the quadtree\r\n       *\r\n       * @example\r\n       * kontra.quadtree().add({id:1}, {id:2}, {id:3});\r\n       * kontra.quadtree().add([{id:1}, {id:2}], {id:3});\r\n       */\n      add() {\n        let i, j, object, obj, indices, index;\n\n        for (j = 0; j < arguments.length; j++) {\n          object = arguments[j];\n\n          // add a group of objects separately\n          if (Array.isArray(object)) {\n            this.add.apply(this, object);\n\n            continue;\n          }\n\n          // current node has subnodes, so we need to add this object into a subnode\n          if (this._b) {\n            this._a(object);\n\n            continue;\n          }\n\n          // this node is a leaf node so add the object to it\n          this.objects.push(object);\n\n          // split the node if there are too many objects\n          if (this.objects.length > this.maxObjects && this._d < this.maxDepth) {\n            this._s();\n\n            // move all objects to their corresponding subnodes\n            for (i = 0; obj = this.objects[i]; i++) {\n              this._a(obj);\n            }\n\n            this.objects.length = 0;\n          }\n        }\n      },\n\n      /**\r\n       * Add an object to a subnode.\r\n       * @memberof kontra.quadtree\r\n       * @private\r\n       *\r\n       * @param {object} object - Object to add into a subnode\r\n       */\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n      _a(object, indices, i) {\n        indices = this._g(object);\n\n        // add the object to all subnodes it intersects\n        for (i = 0; i < indices.length; i++) {\n          this.subnodes[indices[i]].add(object);\n        }\n      },\n\n      /**\r\n       * Determine which subnodes the object intersects with.\r\n       * @memberof kontra.quadtree\r\n       * @private\r\n       *\r\n       * @param {object} object - Object to check.\r\n       *\r\n       * @returns {number[]} List of all subnodes object intersects.\r\n       */\n      _g(object) {\n        let indices = [];\n\n        let verticalMidpoint = this.bounds.x + this.bounds.width / 2;\n        let horizontalMidpoint = this.bounds.y + this.bounds.height / 2;\n\n        // save off quadrant checks for reuse\n        let intersectsTopQuadrants = object.y < horizontalMidpoint && object.y + object.height >= this.bounds.y;\n        let intersectsBottomQuadrants = object.y + object.height >= horizontalMidpoint && object.y < this.bounds.y + this.bounds.height;\n\n        // object intersects with the left quadrants\n        if (object.x < verticalMidpoint && object.x + object.width >= this.bounds.x) {\n          if (intersectsTopQuadrants) {\n            // top left\n            indices.push(0);\n          }\n\n          if (intersectsBottomQuadrants) {\n            // bottom left\n            indices.push(2);\n          }\n        }\n\n        // object intersects with the right quadrants\n        if (object.x + object.width >= verticalMidpoint && object.x < this.bounds.x + this.bounds.width) {\n          // top right\n          if (intersectsTopQuadrants) {\n            indices.push(1);\n          }\n\n          if (intersectsBottomQuadrants) {\n            // bottom right\n            indices.push(3);\n          }\n        }\n\n        return indices;\n      },\n\n      /**\r\n       * Split the node into four subnodes.\r\n       * @memberof kontra.quadtree\r\n       * @private\r\n       */\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n      _s(subWidth, subHeight, i) {\n        this._b = true;\n\n        // only split if we haven't split before\n        if (this.subnodes.length) {\n          return;\n        }\n\n        subWidth = this.bounds.width / 2 | 0;\n        subHeight = this.bounds.height / 2 | 0;\n\n        for (i = 0; i < 4; i++) {\n          this.subnodes[i] = kontra.quadtree({\n            bounds: {\n              x: this.bounds.x + (i % 2 === 1 ? subWidth : 0), // nodes 1 and 3\n              y: this.bounds.y + (i >= 2 ? subHeight : 0), // nodes 2 and 3\n              width: subWidth,\n              height: subHeight\n            },\n            depth: this._d + 1,\n            maxDepth: this.maxDepth,\n            maxObjects: this.maxObjects,\n            /* @if VISUAL_DEBUG */\n            parent: this\n            /* @endif */\n          });\n        }\n      }\n\n    };\n  };\n})();\n\n(function () {\n\n  class Animation {\n    /**\r\n     * Initialize properties on the animation.\r\n     * @memberof kontra.animation\r\n     * @private\r\n     *\r\n     * @param {object} properties - Properties of the animation.\r\n     * @param {object} properties.spriteSheet - Sprite sheet for the animation.\r\n     * @param {number[]} properties.frames - List of frames of the animation.\r\n     * @param {number}  properties.frameRate - Number of frames to display in one second.\r\n     * @param {boolean} [properties.loop=true] - If the animation should loop.\r\n     */\n    // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var\n    constructor(properties, frame) {\n      properties = properties || {};\n\n      this.spriteSheet = properties.spriteSheet;\n      this.frames = properties.frames;\n      this.frameRate = properties.frameRate;\n      this.loop = properties.loop === undefined ? true : properties.loop;\n\n      frame = properties.spriteSheet.frame;\n      this.width = frame.width;\n      this.height = frame.height;\n      this.margin = frame.margin || 0;\n\n      // f = frame, a = accumulator\n      this._f = 0;\n      this._a = 0;\n    }\n\n    /**\r\n     * Clone an animation to be used more than once.\r\n     * @memberof kontra.animation\r\n     *\r\n     * @returns {object}\r\n     */\n    clone() {\n      return kontra.animation(this);\n    }\n\n    /**\r\n     * Reset an animation to the first frame.\r\n     * @memberof kontra.animation\r\n     */\n    reset() {\n      this._f = 0;\n      this._a = 0;\n    }\n\n    /**\r\n     * Update the animation. Used when the animation is not paused or stopped.\r\n     * @memberof kontra.animation\r\n     * @private\r\n     *\r\n     * @param {number} [dt=1/60] - Time since last update.\r\n     */\n    update(dt) {\n\n      // if the animation doesn't loop we stop at the last frame\n      if (!this.loop && this._f == this.frames.length - 1) return;\n\n      dt = dt || 1 / 60;\n\n      this._a += dt;\n\n      // update to the next frame if it's time\n      while (this._a * this.frameRate >= 1) {\n        this._f = ++this._f % this.frames.length;\n        this._a -= 1 / this.frameRate;\n      }\n    }\n\n    /**\r\n     * Draw the current frame. Used when the animation is not stopped.\r\n     * @memberof kontra.animation\r\n     * @private\r\n     *\r\n     * @param {object} properties - How to draw the animation.\r\n     * @param {number} properties.x - X position to draw.\r\n     * @param {number} properties.y - Y position to draw.\r\n     * @param {Context} [properties.context=kontra.context] - Provide a context for the sprite to draw on.\r\n     */\n    render(properties) {\n      properties = properties || {};\n\n      // get the row and col of the frame\n      let row = this.frames[this._f] / this.spriteSheet._f | 0;\n      let col = this.frames[this._f] % this.spriteSheet._f | 0;\n\n      (properties.context || kontra.context).drawImage(this.spriteSheet.image, col * this.width + (col * 2 + 1) * this.margin, row * this.height + (row * 2 + 1) * this.margin, this.width, this.height, properties.x, properties.y, this.width, this.height);\n    }\n  }\n\n  /**\r\n   * Single animation from a sprite sheet.\r\n   * @memberof kontra\r\n   *\r\n   * @param {object} properties - Properties of the animation.\r\n   * @param {object} properties.spriteSheet - Sprite sheet for the animation.\r\n   * @param {number[]} properties.frames - List of frames of the animation.\r\n   * @param {number}  properties.frameRate - Number of frames to display in one second.\r\n   */\n  kontra.animation = function (properties) {\n    return new Animation(properties);\n  };\n  kontra.animation.prototype = Animation.prototype;\n\n  class SpriteSheet {\n    /**\r\n     * Initialize properties on the spriteSheet.\r\n     * @memberof kontra\r\n     * @private\r\n     *\r\n     * @param {object} properties - Properties of the sprite sheet.\r\n     * @param {Image|Canvas} properties.image - Image for the sprite sheet.\r\n     * @param {number} properties.frameWidth - Width (in px) of each frame.\r\n     * @param {number} properties.frameHeight - Height (in px) of each frame.\r\n     * @param {number} properties.frameMargin - Margin (in px) between each frame.\r\n     * @param {object} properties.animations - Animations to create from the sprite sheet.\r\n     */\n    constructor(properties) {\n      properties = properties || {};\n\n      // @if DEBUG\n      if (!properties.image) {\n        throw Error('You must provide an Image for the SpriteSheet');\n      }\n      // @endif\n\n      this.animations = {};\n      this.image = properties.image;\n      this.frame = {\n        width: properties.frameWidth,\n        height: properties.frameHeight,\n        margin: properties.frameMargin\n      };\n\n      // f = framesPerRow\n      this._f = properties.image.width / properties.frameWidth | 0;\n\n      this.createAnimations(properties.animations);\n    }\n\n    /**\r\n     * Create animations from the sprite sheet.\r\n     * @memberof kontra.spriteSheet\r\n     *\r\n     * @param {object} animations - List of named animations to create from the Image.\r\n     * @param {number|string|number[]|string[]} animations.animationName.frames - A single frame or list of frames for this animation.\r\n     * @param {number} animations.animationName.frameRate - Number of frames to display in one second.\r\n     *\r\n     * @example\r\n     * let sheet = kontra.spriteSheet({image: img, frameWidth: 16, frameHeight: 16});\r\n     * sheet.createAnimations({\r\n     *   idle: {\r\n     *     frames: 1  // single frame animation\r\n     *   },\r\n     *   walk: {\r\n     *     frames: '2..6',  // ascending consecutive frame animation (frames 2-6, inclusive)\r\n     *     frameRate: 4\r\n     *   },\r\n     *   moonWalk: {\r\n     *     frames: '6..2',  // descending consecutive frame animation\r\n     *     frameRate: 4\r\n     *   },\r\n     *   jump: {\r\n     *     frames: [7, 12, 2],  // non-consecutive frame animation\r\n     *     frameRate: 3,\r\n     *     loop: false\r\n     *   },\r\n     *   attack: {\r\n     *     frames: ['8..10', 13, '10..8'],  // you can also mix and match, in this case frames [8,9,10,13,10,9,8]\r\n     *     frameRate: 2,\r\n     *     loop: false\r\n     *   }\r\n     * });\r\n     */\n    createAnimations(animations) {\n      let animation, frames, frameRate, sequence, name;\n\n      for (name in animations) {\n        animation = animations[name];\n        frames = animation.frames;\n\n        // array that holds the order of the animation\n        sequence = [];\n\n        // @if DEBUG\n        if (frames === undefined) {\n          throw Error('Animation ' + name + ' must provide a frames property');\n        }\n        // @endif\n\n        // add new frames to the end of the array\n        [].concat(frames).map(function (frame) {\n          sequence = sequence.concat(this._p(frame));\n        }, this);\n\n        this.animations[name] = kontra.animation({\n          spriteSheet: this,\n          frames: sequence,\n          frameRate: animation.frameRate,\n          loop: animation.loop\n        });\n      }\n    }\n\n    /**\r\n     * Parse a string of consecutive frames.\r\n     * @memberof kontra.spriteSheet\r\n     * @private\r\n     *\r\n     * @param {number|string} frames - Start and end frame.\r\n     *\r\n     * @returns {number[]} List of frames.\r\n     */\n    _p(consecutiveFrames, i) {\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n      if (+consecutiveFrames === consecutiveFrames) {\n        return consecutiveFrames;\n      }\n\n      let sequence = [];\n      let frames = consecutiveFrames.split('..');\n\n      // coerce string to number\n      // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n      let start = i = +frames[0];\n      let end = +frames[1];\n\n      // ascending frame order\n      if (start < end) {\n        for (; i <= end; i++) {\n          sequence.push(i);\n        }\n      }\n      // descending order\n      else {\n          for (; i >= end; i--) {\n            sequence.push(i);\n          }\n        }\n\n      return sequence;\n    }\n  }\n\n  /**\r\n   * Create a sprite sheet from an image.\r\n   * @memberof kontra\r\n   *\r\n   * @param {object} properties - Properties of the sprite sheet.\r\n   * @param {Image|Canvas} properties.image - Image for the sprite sheet.\r\n   * @param {number} properties.frameWidth - Width (in px) of each frame.\r\n   * @param {number} properties.frameHeight - Height (in px) of each frame.\r\n   * @param {number} properties.frameMargin - Margin (in px) between each frame.\r\n   * @param {object} properties.animations - Animations to create from the sprite sheet.\r\n   */\n  kontra.spriteSheet = function (properties) {\n    return new SpriteSheet(properties);\n  };\n  kontra.spriteSheet.prototype = SpriteSheet.prototype;\n})();\n\n(function () {\n  // save Math.min and Math.max to variable and use that instead\n\n  /**\r\n   * A tile engine for rendering tilesets. Works well with the tile engine program Tiled.\r\n   * @memberof kontra\r\n   *\r\n   * @param {object} properties - Properties of the tile engine.\r\n   * @param {number} [properties.tileWidth=32] - Width of a tile.\r\n   * @param {number} [properties.tileHeight=32] - Height of a tile.\r\n   * @param {number} properties.width - Width of the map (in tiles).\r\n   * @param {number} properties.height - Height of the map (in tiles).\r\n   * @param {number} [properties.x=0] - X position to draw.\r\n   * @param {number} [properties.y=0] - Y position to draw.\r\n   * @param {number} [properties.sx=0] - X position to clip the tileset.\r\n   * @param {number} [properties.sy=0] - Y position to clip the tileset.\r\n   * @param {Context} [properties.context=kontra.context] - Provide a context for the tile engine to draw on.\r\n   */\n  kontra.tileEngine = function (properties) {\n    properties = properties || {};\n\n    // size of the map (in tiles)\n    // @if DEBUG\n    if (!properties.width || !properties.height) {\n      throw Error('You must provide width and height properties');\n    }\n    // @endif\n\n    /**\r\n     * Get the index of the x, y or row, col.\r\n     * @memberof kontra.tileEngine\r\n     * @private\r\n     *\r\n     * @param {number} position.x - X coordinate of the tile.\r\n     * @param {number} position.y - Y coordinate of the tile.\r\n     * @param {number} position.row - Row of the tile.\r\n     * @param {number} position.col - Col of the tile.\r\n     *\r\n     * @return {number} Returns the tile index or -1 if the x, y or row, col is outside the dimensions of the tile engine.\r\n     */\n    function getIndex(position) {\n      let row, col;\n\n      if (typeof position.x !== 'undefined' && typeof position.y !== 'undefined') {\n        row = tileEngine.getRow(position.y);\n        col = tileEngine.getCol(position.x);\n      } else {\n        row = position.row;\n        col = position.col;\n      }\n\n      // don't calculate out of bound numbers\n      if (row < 0 || col < 0 || row >= height || col >= width) {\n        return -1;\n      }\n\n      return col + row * width;\n    }\n\n    /**\r\n     * Modified binary search that will return the tileset associated with the tile\r\n     * @memberof kontra.tileEngine\r\n     * @private\r\n     *\r\n     * @param {number} tile - Tile grid.\r\n     *\r\n     * @return {object}\r\n     */\n    function getTileset(tile) {\n      let min = 0;\n      let max = tileEngine.tilesets.length - 1;\n      let index, currTile;\n\n      while (min <= max) {\n        index = (min + max) / 2 | 0;\n        currTile = tileEngine.tilesets[index];\n\n        if (tile >= currTile.firstGrid && tile <= currTile.lastGrid) {\n          return currTile;\n        } else if (currTile.lastGrid < tile) {\n          min = index + 1;\n        } else {\n          max = index - 1;\n        }\n      }\n    }\n\n    /**\r\n     * Pre-render the tiles to make drawing fast.\r\n     * @memberof kontra.tileEngine\r\n     * @private\r\n     */\n    function preRenderImage() {\n      let tile, tileset, image, x, y, sx, sy, tileOffset, w;\n\n      // draw each layer in order\n      for (let i = 0, layer; layer = tileEngine.layers[layerOrder[i]]; i++) {\n        for (let j = 0, len = layer.data.length; j < len; j++) {\n          tile = layer.data[j];\n\n          // skip empty tiles (0)\n          if (!tile) {\n            continue;\n          }\n\n          tileset = getTileset(tile);\n          image = tileset.image;\n\n          x = j % width * tileWidth;\n          y = (j / width | 0) * tileHeight;\n\n          tileOffset = tile - tileset.firstGrid;\n          w = image.width / tileWidth;\n\n          sx = tileOffset % w * tileWidth;\n          sy = (tileOffset / w | 0) * tileHeight;\n\n          offscreenContext.drawImage(image, sx, sy, tileWidth, tileHeight, x, y, tileWidth, tileHeight);\n        }\n      }\n    }\n\n    let width = properties.width;\n    let height = properties.height;\n\n    // size of the tiles. Most common tile size on opengameart.org seems to be 32x32,\n    // followed by 16x16\n    // Tiled names the property tilewidth and tileheight\n    let tileWidth = properties.tileWidth || properties.tilewidth || 32;\n    let tileHeight = properties.tileHeight || properties.tileheight || 32;\n\n    let mapWidth = width * tileWidth;\n    let mapHeight = height * tileHeight;\n\n    let context = properties.context || kontra.context;\n    let canvasWidth = context.canvas.width;\n    let canvasHeight = context.canvas.height;\n\n    // create an off-screen canvas for pre-rendering the map\n    // @see http://jsperf.com/render-vs-prerender\n    let offscreenCanvas = document.createElement('canvas');\n    let offscreenContext = offscreenCanvas.getContext('2d');\n\n    // when clipping an image, sx and sy must within the image region, otherwise\n    // Firefox and Safari won't draw it.\n    // @see http://stackoverflow.com/questions/19338032/canvas-indexsizeerror-index-or-size-is-negative-or-greater-than-the-allowed-a\n    let sxMax = Math.max(0, mapWidth - canvasWidth);\n    let syMax = Math.max(0, mapHeight - canvasHeight);\n\n    let _sx, _sy;\n\n    // draw order of layers (by name)\n    let layerOrder = [];\n\n    let tileEngine = {\n      width: width,\n      height: height,\n\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n\n      mapWidth: mapWidth,\n      mapHeight: mapHeight,\n\n      context: context,\n\n      x: properties.x || 0,\n      y: properties.y || 0,\n\n      tilesets: [],\n      layers: {},\n\n      /**\r\n       * Add an tileset for the tile engine to use.\r\n       * @memberof kontra.tileEngine\r\n       *\r\n       * @param {object|object[]} tileset - Properties of the image to add.\r\n       * @param {Image|Canvas} tileset.image - Path to the image or Image object.\r\n       * @param {number} tileset.firstGrid - The first tile grid to start the image.\r\n       */\n      addTilesets: function addTilesets(tilesets) {\n        [].concat(tilesets).map(function (tileset) {\n          let tilesetImage = tileset.image;\n          let image, firstGrid, numTiles, lastTileset, tiles;\n\n          // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n          if ('' + tilesetImage === tilesetImage) {\n            let i = Infinity;\n\n            while (i >= 0) {\n              i = tilesetImage.lastIndexOf('/', i);\n              let path = i < 0 ? tilesetImage : tilesetImage.substr(i);\n\n              if (kontra.assets.images[path]) {\n                image = kontra.assets.images[path];\n                break;\n              }\n\n              i--;\n            }\n          } else {\n            image = tilesetImage;\n          }\n\n          firstGrid = tileset.firstGrid;\n\n          // if the width or height of the provided image is smaller than the tile size,\n          // default calculation to 1\n          numTiles = (image.width / tileWidth | 0 || 1) * (image.height / tileHeight | 0 || 1);\n\n          if (!firstGrid) {\n            // only calculate the first grid if the tile map has a tileset already\n            if (tileEngine.tilesets.length > 0) {\n              lastTileset = tileEngine.tilesets[tileEngine.tilesets.length - 1];\n              tiles = (lastTileset.image.width / tileWidth | 0) * (lastTileset.image.height / tileHeight | 0);\n\n              firstGrid = lastTileset.firstGrid + tiles;\n            }\n            // otherwise this is the first tile added to the tile map\n            else {\n                firstGrid = 1;\n              }\n          }\n\n          tileEngine.tilesets.push({\n            firstGrid: firstGrid,\n            lastGrid: firstGrid + numTiles - 1,\n            image: image\n          });\n\n          // sort the tile map so we can perform a binary search when drawing\n          tileEngine.tilesets.sort(function (a, b) {\n            return a.firstGrid - b.firstGrid;\n          });\n        });\n      },\n\n      /**\r\n       * Add a layer to the tile engine.\r\n       * @memberof kontra.tileEngine\r\n       *\r\n       * @param {object} properties - Properties of the layer to add.\r\n       * @param {string} properties.name - Name of the layer.\r\n       * @param {number[]} properties.data - Tile layer data.\r\n       * @param {boolean} [properties.render=true] - If the layer should be drawn.\r\n       * @param {number} [properties.zIndex] - Draw order for tile layer. Highest number is drawn last (i.e. on top of all other layers).\r\n       */\n      addLayers: function addLayers(layers) {\n        [].concat(layers).map(function (layer) {\n          layer.render = layer.render === undefined ? true : layer.render;\n\n          let data, r, row, c, prop, value;\n\n          // flatten a 2D array into a single array\n          if (Array.isArray(layer.data[0])) {\n            data = [];\n\n            for (r = 0; row = layer.data[r]; r++) {\n              for (c = 0; c < width; c++) {\n                data.push(row[c] || 0);\n              }\n            }\n          } else {\n            data = layer.data;\n          }\n\n          tileEngine.layers[layer.name] = {\n            data: data,\n            zIndex: layer.zIndex || 0,\n            render: layer.render\n          };\n\n          // merge properties of layer onto layer object\n          for (prop in layer.properties) {\n            value = layer.properties[prop];\n\n            try {\n              value = JSON.parse(value);\n            } catch (e) {}\n\n            tileEngine.layers[layer.name][prop] = value;\n          }\n\n          // only add the layer to the layer order if it should be drawn\n          if (tileEngine.layers[layer.name].render) {\n            layerOrder.push(layer.name);\n\n            layerOrder.sort(function (a, b) {\n              return tileEngine.layers[a].zIndex - tileEngine.layers[b].zIndex;\n            });\n          }\n        });\n\n        preRenderImage();\n      },\n\n      /**\r\n       * Simple bounding box collision test for layer tiles.\r\n       * @memberof kontra.tileEngine\r\n       *\r\n       * @param {string} name - Name of the layer.\r\n       * @param {object} object - Object to check collision against.\r\n       * @param {number} object.x - X coordinate of the object.\r\n       * @param {number} object.y - Y coordinate of the object.\r\n       * @param {number} object.width - Width of the object.\r\n       * @param {number} object.height - Height of the object.\r\n       *\r\n       * @returns {boolean} True if the object collides with a tile, false otherwise.\r\n       */\n      layerCollidesWith: function layerCollidesWith(name, object) {\n        // calculate all tiles that the object can collide with\n        let row = tileEngine.getRow(object.y);\n        let col = tileEngine.getCol(object.x);\n\n        let endRow = tileEngine.getRow(object.y + object.height);\n        let endCol = tileEngine.getCol(object.x + object.width);\n\n        // check all tiles\n        let index;\n        for (let r = row; r <= endRow; r++) {\n          for (let c = col; c <= endCol; c++) {\n            index = getIndex({ row: r, col: c });\n\n            if (tileEngine.layers[name].data[index]) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      },\n\n      /**\r\n       * Get the tile from the specified layer at x, y or row, col.\r\n       * @memberof kontra.tileEngine\r\n       *\r\n       * @param {string} name - Name of the layer.\r\n       * @param {object} position - Position of the tile in either x, y or row, col.\r\n       * @param {number} position.x - X coordinate of the tile.\r\n       * @param {number} position.y - Y coordinate of the tile.\r\n       * @param {number} position.row - Row of the tile.\r\n       * @param {number} position.col - Col of the tile.\r\n       *\r\n       * @returns {number}\r\n       */\n      tileAtLayer: function tileAtLayer(name, position) {\n        let index = getIndex(position);\n\n        if (index >= 0) {\n          return tileEngine.layers[name].data[index];\n        }\n      },\n\n      /**\r\n       * Render the pre-rendered canvas.\r\n       * @memberof kontra.tileEngine\r\n       */\n      render: function render() {\n        /* istanbul ignore next */\n        tileEngine.context.drawImage(offscreenCanvas, tileEngine.sx, tileEngine.sy, canvasWidth, canvasHeight, tileEngine.x, tileEngine.y, canvasWidth, canvasHeight);\n      },\n\n      /**\r\n       * Render a specific layer.\r\n       * @memberof kontra.tileEngine\r\n       *\r\n       * @param {string} name - Name of the layer to render.\r\n       */\n      renderLayer: function renderLayer(name) {\n        let layer = tileEngine.layers[name];\n\n        // calculate the starting tile\n        let row = tileEngine.getRow();\n        let col = tileEngine.getCol();\n        let index = getIndex({ row: row, col: col });\n\n        // calculate where to start drawing the tile relative to the drawing canvas\n        let startX = col * tileWidth - tileEngine.sx;\n        let startY = row * tileHeight - tileEngine.sy;\n\n        // calculate how many tiles the drawing canvas can hold\n        let viewWidth = Math.min(Math.ceil(canvasWidth / tileWidth) + 1, width);\n        let viewHeight = Math.min(Math.ceil(canvasHeight / tileHeight) + 1, height);\n        let numTiles = viewWidth * viewHeight;\n\n        let count = 0;\n        let x, y, tile, tileset, image, tileOffset, w, sx, sy;\n\n        // draw just enough of the layer to fit inside the drawing canvas\n        while (count < numTiles) {\n          tile = layer.data[index];\n\n          if (tile) {\n            tileset = getTileset(tile);\n            image = tileset.image;\n\n            x = startX + count % viewWidth * tileWidth;\n            y = startY + (count / viewWidth | 0) * tileHeight;\n\n            tileOffset = tile - tileset.firstGrid;\n            w = image.width / tileWidth;\n\n            sx = tileOffset % w * tileWidth;\n            sy = (tileOffset / w | 0) * tileHeight;\n\n            tileEngine.context.drawImage(image, sx, sy, tileWidth, tileHeight, x, y, tileWidth, tileHeight);\n          }\n\n          if (++count % viewWidth === 0) {\n            index = col + ++row * width;\n          } else {\n            index++;\n          }\n        }\n      },\n\n      /**\r\n       * Get the row from the y coordinate.\r\n       * @memberof kontra.tileEngine\r\n       *\r\n       * @param {number} y - Y coordinate.\r\n       *\r\n       * @return {number}\r\n       */\n      getRow: function getRow(y) {\n        y = y || 0;\n\n        return (tileEngine.sy + y) / tileHeight | 0;\n      },\n\n      /**\r\n       * Get the col from the x coordinate.\r\n       * @memberof kontra.tileEngine\r\n       *\r\n       * @param {number} x - X coordinate.\r\n       *\r\n       * @return {number}\r\n       */\n      getCol: function getCol(x) {\n        x = x || 0;\n\n        return (tileEngine.sx + x) / tileWidth | 0;\n      },\n\n      get sx() {\n        return _sx;\n      },\n\n      get sy() {\n        return _sy;\n      },\n\n      // ensure sx and sy are within the image region\n      set sx(value) {\n        _sx = Math.min(Math.max(0, value), sxMax);\n      },\n\n      set sy(value) {\n        _sy = Math.min(Math.max(0, value), syMax);\n      },\n\n      // expose properties for testing\n      // @if DEBUG\n      _layerOrder: layerOrder\n      // @endif\n    };\n\n    // set here so we use setter function\n    tileEngine.sx = properties.sx || 0;\n    tileEngine.sy = properties.sy || 0;\n\n    // make the off-screen canvas the full size of the map\n    offscreenCanvas.width = mapWidth;\n    offscreenCanvas.height = mapHeight;\n\n    // merge properties of the tile engine onto the tile engine itself\n    for (let prop in properties.properties) {\n      let value = properties.properties[prop];\n\n      try {\n        value = JSON.parse(value);\n      } catch (e) {}\n\n      // passed in properties override properties.properties\n      tileEngine[prop] = tileEngine[prop] || value;\n    }\n\n    if (properties.tilesets) {\n      tileEngine.addTilesets(properties.tilesets);\n    }\n\n    if (properties.layers) {\n      tileEngine.addLayers(properties.layers);\n    }\n\n    return tileEngine;\n  };\n})();\n\n/**\r\n * Object for using localStorage.\r\n */\nkontra.store = {\n\n  /**\r\n   * Save an item to localStorage.\r\n   * @memberof kontra.store\r\n   *\r\n   * @param {string} key - Name to store the item as.\r\n   * @param {*} value - Item to store.\r\n   */\n  set(key, value) {\n    if (value === undefined) {\n      localStorage.removeItem(key);\n    } else {\n      localStorage.setItem(key, JSON.stringify(value));\n    }\n  },\n\n  /**\r\n   * Retrieve an item from localStorage and convert it back to it's original type.\r\n   * @memberof kontra.store\r\n   *\r\n   * @param {string} key - Name of the item.\r\n   *\r\n   * @returns {*}\r\n   */\n  get(key) {\n    let value = localStorage.getItem(key);\n\n    try {\n      value = JSON.parse(value);\n    } catch (e) {}\n\n    return value;\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (kontra);\n\n//# sourceURL=webpack:///./kontra.js?");

/***/ })

/******/ });